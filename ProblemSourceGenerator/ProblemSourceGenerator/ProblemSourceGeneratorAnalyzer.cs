using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ProblemSourceGenerator
{
    [Generator]
    public sealed class ProblemSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                    transform: static (ctx, _) => GetCandidate(ctx))
                .Where(static c => c is not null)
                .Collect(); // ImmutableArray<ProblemCandidate?>

            context.RegisterSourceOutput(provider, static (spc, items) => Execute(spc, items));
        }

        private static ProblemCandidate? GetCandidate(GeneratorSyntaxContext ctx)
        {
            if (ctx.Node is not ClassDeclarationSyntax classDecl) return null;
            var model = ctx.SemanticModel;
            if (model.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol) return null;

            foreach (var attr in classDecl.AttributeLists.SelectMany(al => al.Attributes))
            {
                var attrSymbol = model.GetSymbolInfo(attr).Symbol as IMethodSymbol;
                var attrType = attrSymbol?.ContainingType;
                if (attrType is null) continue;

                var fullName = attrType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (fullName != "global::Problems.ProblemAttribute") continue;

                string? dateStr = null;
                if (attr.ArgumentList is { Arguments.Count: > 0 })
                {
                    var expr = attr.ArgumentList.Arguments[0].Expression;
                    var constVal = model.GetConstantValue(expr);
                    if (constVal.HasValue) dateStr = constVal.Value?.ToString();
                }

                var typeFqn = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return new ProblemCandidate(typeFqn, dateStr, attr.GetLocation());
            }

            return null;
        }

        private static void Execute(SourceProductionContext context, ImmutableArray<ProblemCandidate?> candidates)
        {
            var map = new Dictionary<(int Year, int Month, int Day), string>();
            foreach (var c in candidates)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("LSGDBG", "Debug", $"Candidate: {c?.TypeFqn}, date={c?.DateString}",
                                             "Debug", DiagnosticSeverity.Info, true),
                    Location.None));
                if (c is null) continue;

                if (string.IsNullOrWhiteSpace(c.DateString) ||
                    !DateTime.TryParseExact(c.DateString, "yyyy-MM-dd", CultureInfo.InvariantCulture,
                                            DateTimeStyles.None, out var dt))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        Descriptors.InvalidDate, c.Location, c.DateString ?? "<null>"));
                    continue;
                }

                var key = (dt.Year, dt.Month, dt.Day);
                if (map.ContainsKey(key))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        Descriptors.DuplicateDate, c.Location, dt.ToString("yyyy-MM-dd")));
                    continue;
                }

                map[key] = c.TypeFqn;
            }

            // Generate code with a dictionary and a method that returns Type by date 
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine("namespace Problems.Generated;");
            sb.AppendLine();
            sb.AppendLine("public static partial class ProblemRegistry");
            sb.AppendLine("{");
            sb.AppendLine("    public static readonly Dictionary<DateOnly, Type> Problems = new()");
            sb.AppendLine("    {");

            foreach (var kv in map.OrderBy(k => k.Key))
            {
                var (y, m, d) = kv.Key;
                var type = kv.Value;
                sb.AppendLine($"        [new DateOnly({y}, {m}, {d})] = typeof({type}),");
            }

            sb.AppendLine("    };");
            sb.AppendLine();
            sb.AppendLine("    public static bool TryCreate(DateOnly date, out Problems.IProblem? instance)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (Problems.TryGetValue(date, out var t))");
            sb.AppendLine("        {");
            sb.AppendLine("            instance = (Problems.IProblem?)Activator.CreateInstance(t);");
            sb.AppendLine("            return instance is not null;");
            sb.AppendLine("        }");
            sb.AppendLine("        instance = null;");
            sb.AppendLine("        return false;");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            context.AddSource("ProblemRegistry.g.cs", sb.ToString());
        }

        private class ProblemCandidate(string typeFqn, string? dateString, Location? location)
        {
            public string TypeFqn { get; } = typeFqn;
            public string? DateString { get; } = dateString;
            public Location? Location { get; } = location;
        }

        private static class Descriptors
        {
            public static readonly DiagnosticDescriptor InvalidDate = new(
                id: "LSG001",
                title: "Invalid date in [Problem]",
                messageFormat: "Value '{0}' is not a valid date in format yyyy-MM-dd",
                category: "LeetSolving.Generators",
                defaultSeverity: DiagnosticSeverity.Error,
                isEnabledByDefault: true);

            public static readonly DiagnosticDescriptor DuplicateDate = new(
                id: "LSG002",
                title: "Duplicate date in [Problem]",
                messageFormat: "A problem for date '{0}' is already defined",
                category: "LeetSolving.Generators",
                defaultSeverity: DiagnosticSeverity.Error,
                isEnabledByDefault: true);
        }
    }
}
